#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
//操作符详解
//1.操作符分类
//算术操作符
//移位操作符
//位操作符
//赋值操作符
//单目操作符
//关系操作符
//逻辑操作符
//条件操作符
//逗号表达式
//下标引用、函数调用和结构成员
//2.算术操作符
//     + - * / %
//1. 除了 % 操作符之外，其他的几个操作符可以作用于整数和浮点数。
//2. 对于 / 操作符如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除法。
//3. % 操作符的两个操作数必须为整数。返回的是整除之后的余数。
//int main()
//{
//	int a = 5 / 2;//商2余1   /得到的是商
//	printf("a = %d\n", a);对于 / 操作符如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除法。
//	return 0;
//}
//int main()
//{
//	int a = 5 % 2;//  %得到的是余数
//	printf("a = %d\n", a);
//	return 0;
//}
//3. 移位操作符
//<< 左移操作符
//>> 右移操作符
//注：移位操作符的操作数只能是整数。
//3.1 左移操作符
//移位规则：
//左边抛弃、右边补0
//int main()
//{
//	int a = 5;
//	int b = a << 1;
//	//000000000000000000000101
//	printf("%d", b);
//	return 0;
//}
//3.2 右移操作符
//移位规则：
//首先右移运算分两种：
//1. 逻辑移位（右移）
//左边用0填充，右边丢弃
//2. 算术移位
//左边用原该值的符号位填充，右边丢弃（正补0.负补1）
//int main()
//{
//	int a = 16;
//	int b = a >> 1;
//	// “>>”  -- 右移操作符
//	//移动的是二进制位
//	printf("%d", b);
//	return 0;
//}
//警告⚠ ：对于移位运算符，不要移动负数位，这个是标准未定义的。
//4.位操作符
//位操作符有：
//  &   按位与
//  |   按位或
//  ^   按位异或
//注：他们的操作数必须是整数。
// & 按位与
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a & b;
//	//011
//	//101
//	//001  只要一个是0就为0，两个都为1才为1
//	printf("%d", c);
//	return 0;
//}
// |   按位或
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a | b;
//	printf("%d\n", c);
//	return 0;//只要是一个为1就为1，两个为0才为0
//}
// ^ 按位异或
//int main()
//{
//	int a = 3;
//   int b = 5;
//	int c = a ^ b;
//	printf("%d\n", c);
// 011
// 101
// 110
//	return 0;相同为0；相异为1
//}
// a = a ^ b;
// b = a ^ b;
// a = a ^ b;
// 编写代码实现：求一个整数存储在内存中的二进制中1的个数。
// int main()
//{
//	//int num = 0;
//	//scanf("%d", &num);
//	////统计num的二进制补码中有几个1
//	//while (num)
//	//{
//	//	if (num % 2 == 1)
//	//		count++;
//	//	num = num / 2;
//	//}
//	//printf("%d\n", count);// -1 不行

//	int num = 0;
//	int count = 0;
//	scanf("%d", &num);
//	int i = 0;
//	for (i = 0; i < 32; i++)
//	{
//		if (1 == ((num >> i) & 1))//当i为0时，num先向右移0位，然后相与，当i为0时，num先向右移1位，然后相与等等就能算出32个中有多少1
//			count++;
//	}
//	printf("%d\n", count);
//	return 0;
//}
//5. 赋值操作符
//赋值操作符是一个很棒的操作符，他可以让你得到一个你之前不满意的值。也就是你可以给自己重新赋值。
//复合赋值符
//  +=   -=    *=   /=   %=   >>=   <<=    &=    |=    ^= 
//6. 单目操作符
//6.1 单目操作符介绍
// !  逻辑反操作
// -  负值
// +  正值
// &  取地址
// sizeof      操作数的类型长度（以字节为单位）
// ~   对一个数的二进制按位取反
// --  前置、后置--
// ++  前置、后置++
// *  间接访问操作符(解引用操作符)
// (类型) 强制类型转换
//关于sizeof其实我们之前已经见过了，可以求变量（类型）所占空间的大小。
//int main()
//{
//	//int a = 0;
//	//printf("%d\n", !a);//真变成假，假变成真
//	int a = 10;
//	int* p = &a;//取地址操作符
//	*p = 20;//解引用操作符
//	return 0;
//}
//int main()
//{
	//int a = 10;
	//char c = 'r';
	//char* p = &c;
	//int arr[10] = { 0 };//sizeof 计算的变量所占内存空间的大小，单位是字节。
	//printf("%d\n", sizeof(a));//整型大小为4个字节
	//printf("%d\n", sizeof(c));//char 为1个字符
	//printf("%d\n", sizeof(p));//为指针4个字节或者8个字节
	//printf("%d\n", sizeof(arr));//这个数组为10个元素，每个元素为一个整型。10个整型为40个字节
//	short s = 0;
//	int a = 10;
//	printf("%d\n", sizeof(s = a + 5));//s是一个short，短整型只能存储2个字节的大小。sizeof计算的变量所占内存空间的大小所以为2
//	printf("%d\n", s);//s里面所放的值不会参加运算，所以s还是0
//	return 0;
//}
//int main()
//{
	//int a = 0;
	// ~ 按（2进制）位取反
	//00000000000000000000000000000000  计算机在内存中存储的是补码
	//11111111111111111111111111111111   -补码（即使按位取反还是补码）
	//11111111111111111111111111111110   -反码  补码-1是反码
	//10000000000000000000000000000001   -原码   符号位不变，其他位按位取反
	//-1
	//printf("%d\n", ~a);//%d打印的就是原码
	//return 0;
//}
//数字为11（1011），1，两个数通过操作符运算变成15（1111），然后再通过操作符运算，变成11（1011）
//00000000000000000000000000001011
//00000000000000000000000000000100   - 1向左移2位   1<<2
//00000000000000000000000000001111   - 按位或  | 只要一个为1就为1，两个都为0才为0
// 15
//11111111111111111111111111111011   - ~（1<<2) [将向右移两位的数再按位取反] 
//00000000000000000000000000001111   - 按位与  & 只要一个为0就为0，两个为1才为1
//00000000000000000000000000001011
// 11
//int main()
//{
//	int a = 11;
//	a = a | (1 << 2);
//	printf("%d\n", a);//15
//	a = a & (~(1 << 2));
//	printf("%d\n", a);//11
//	return 0;
//}
// --  前置、后置--
// ++  前置、后置++
//int main()
//{
	//int a = 10;
	//printf("%d\n", ++a);//++前置  先++，后使用
	//printf("%d\n", a++);//++后置  先使用，再++
	//return 0;
//}
// (类型) 强制类型转换
//int main()
//{
//	int a = (int)3.14;//(  )
//	printf("%d", a);
//	return 0;
//}
//7. 关系操作符
//关系操作符
// >   >=   <   <=  	!=   用于测试“不相等”	== 用于测试“相等”
//警告：在编程的过程中 == 和 = 不小心写错，导致的错误。
//8. 逻辑操作符
//&&     逻辑与  || 逻辑或
//区分逻辑与和按位与
//区分逻辑或和按位或
// 1&2----->0  
// 1 && 2---- > 1  逻辑与 都为真，结果才为真。一个为假都为假
// 1 | 2----->3
// 1 || 2---- > 1  逻辑或 一个为真都为真。 都为假，结果才为假
//int main()
//{
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
//	i = a++ && ++b && d++;//1 2 3 4
//	int i = 0, a = 1, b = 2, c = 3, d = 4;
//	i = a++ || ++b || d++;//2 2 3 4
//	printf(" a = %d\n b = %d\n c = %d\n d = %d\n", a, b, c, d);
//	return 0;
//}
//9.条件操作符
//exp1 ? exp2 : exp3  1真算2，1假算3
//int main()
//{
//	//int a = 0;
//	//int b = 0;
//	//b = a > 5 ? 3 : -2;//如果a>5,就输出3否则就输出-2
//	//printf("%d\n",b);
//	int a = 10;
//	int b = 20;
//	int max = 0;
//	max = (a > b ? a : b);//如果a>b,就输出a的值。否则就输出b的值
//	printf("%d\n", max);
//	return 0;
//}
//10. 逗号表达式
//exp1, exp2, exp3, .....expN
//逗号表达式，就是用逗号隔开的多个表达式。
//逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果。
//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = (a > b, a = b + 10, a, b = a + 1);//a = b + 10(12)→b = a + 1（13）
//	printf("%d\n", c);//13
//	return 0;
//}
//11. 下标引用、函数调用和结构成员
//1.[] 下标引用操作符
//操作数：一个数组名 + 一个索引值
//int main()
//{
//	int arr[10] = { 0 };//创建数组,里面有10个元素
//	arr[9] = 10;//实用下标引用操作符。[]的两个操作数是arr和9
//	return 0;
//}
//2. () 函数调用操作符
//接受一个或者多个操作数：第一个操作数是函数名，剩余的操作数就是传递给函数的参数。
//int get_max(int x, int y)
//{
//	return x > y ? x : y;
//}
//int main()
//{
//	int a = 10;
//	int b = 20;
//	//调用函数的时候（）就是函数调用操作符
//	int max = get_max(a, b);//第一个操作数就是get_max,剩余操作数a,b
//	printf("max = %d\n", max);
//	return 0;
//}
//3. 访问一个结构的成员
//.   结构体.成员名
//->  结构体指针->成员名
// 
//创建一个结构体类型  struct Stu
//struct Stu
//{
//	char name[20];
//	int age;
//	char id[20];
//};
//int main()
//{
//	int a = 10;
//	//使用struct Stu这个类型创建了一个学生对象s1，并初始化
//	struct Stu s1 = { "张三",20,"20135694878" };//结构体类型是Stu,成员名是s1就是对象
//	struct Stu* ps = &s1;
//	//printf("%s\n", s1.name);
//	//printf("%d\n", s1.age);   结构体.成员名
//	//printf("%s\n", s1.id);
//	//结构体变量，成员名
//
//	printf("%s\n", ps->name);
//	printf("%d\n", ps->name);//结构体指针->成员名
//	return 0;
//}
//12. 表达式求值
//表达式求值的顺序一部分是由操作符的优先级和结合性决定。
//同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型。
//12.1 隐式类型转换
//C的整型算术运算总是至少以缺省整型类型的精度来进行的。
//为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升。
//b和c的值被提升为普通整型，然后再执行加法运算。
//加法运算完成之后，结果将被截断，然后再存储于a中。
//int main()
//{   //char类型有一个字节，因此在计算时要进行转换为普通整型，这种转换称为整型提升
//	char a = 3;//整型比特位 00000000000000000000000000000011
//	char b = 127;  //整型比特位00000000000000000000000001111111
//	char c = a + b;//a和b相加为00000000000000000000000010000010
//	//c为char只能放一个字节，要进行截断  结果为10000010
//	//当c为一个char时进行整型提升，而c存储在内存中时是补码，%d打印时转换为原码为-126
//	//这次整型提升时补的是11111111111111111111111110000010是存在内存中的
//	//11111111111111111111111110000010  -补码
//	//11111111111111111111111110000001  -反码
//	//00000000000000000000000001111110  -原码
//	printf("%d\n", c);//-126
//	return 0;
//在计算的过程中，发现表达式当中，有些操作数的大小是达不到整型大小的时候，会进行整型提升，变成一个整型参与运算
//怎样进行整型提升的  首先，我们看这个变量的类型是什么类型，是有符号数的话，高位就按照高位的符号位补充，直到32位，如果是无符号数高位补0
//}
//12.2 算术转换
//如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类
//型，否则操作就无法进行。下面的层次体系称为寻常算术转换。
// long double
//double
//float
//unsigned long int
//long int
//unsigned int
//int
//如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运算。
//警告：但是算术转换要合理，要不然会有一些潜在的问题。
//12.3 操作符的属性
//复杂表达式的求值有三个影响的因素。
//1. 操作符的优先级
//2. 操作符的结合性
//3. 是否控制求值顺序。
//两个相邻的操作符先执行哪个？取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。
//操作符优先级
